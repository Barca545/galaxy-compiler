mod ast;
mod errors;
mod interner;
mod parser;
mod reg_allocator;
mod symbol_table;
mod tests;
mod token;
mod tokenizer;

use parser::Parser;

// Switch how equal signs are handled?
// https://craftinginterpreters.com/global-variables.html#assignment
// To fix this, variable() should look for and consume the = only if it’s in
// the context of a low-precedence expression. The code that knows the
// current precedence is, logically enough, parsePrecedence(). The
// variable() function doesn’t need to know the actual level. It just
// cares that the precedence is low enough to allow assignment, so we
// pass that fact in as a Boolean.

// TODO
// - Remove this from the engine file.
// - Finish the Parser
// - Add a way to compile the AST generated by the parser to bytecode
// - Add a symbol table
// - Add type checking
// - Check return type matches the signature
// - Add register allocation
// - Add linking?
// - Add memory allocator to the VM: https://discord.com/channels/816484635273199626/974884085606518824/1273574064266678315
// - Set up some way to switch out the file it's compiling and interact with the
//   compiler.
// - Add back the error checking for the Parser
//    - Eat token expect is not working because it has a hardcoded error message
//      and does not print the input error
//    - Erroring if tuples are not closed

// Refactor:
// - Move the tests into their own module.
// - let const instead of let mut? -> no mut keyword for declarations only for
//   references?
// - Remove range pattern?
// - Only one number type which can be either an int or a float
// - Add some sort of type table?
// - Blocks should only require semicolons if they are also part of a
//   declaration
// - Special error reporting for returns in the wrong place
// - Should not require blocks to have semicolons after them
//    - Correct statement erroring so expression-statements do not require
//      semicolons

// Lang Features
// - Type checking
// - Default args
// - Custom/semantic types?
// - Type inference
// - Importing?
// - Documenting comments that generate HTML?
// - Only dynamic arrays (vectors) defined in std?
// - Track never used

fn main() {
  let mut parser = Parser::new("fdfd",);
  let _ast = parser.parse();
}
